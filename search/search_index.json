{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OpenShift Builds \u00b6 About this Workshop \u00b6 A Build is the process to transform source code into a runnable image. A BuildConfig object is the definition of the entire build process. There are three primary Build strategies in OpenShift Container Platform (OCP) 4.x: Docker build, Source-to-Image (S2I) build, Custom build. The Pipeline build strategy using Jenkins is deprecated in OpenShift Container Platform (OCP) 4.x. The Jenkins pipeline is still available via the Jenkins operator. Equivalent and improved functionality is present in the OpenShift Pipelines based on Tekton . Agenda \u00b6 Setup Pre-requirements for the workshop. Docker build Use Docker build strategy. Source-to-Image (S2I) Use Source-to-Image (S2I) build strategy. Pipeline build Use a Jenkins Pipeline and OpenShift Pipeline build strategy. Tekton Deployment Use Tekton to Deploy to OpenShift. See also Tekton Resources Compatibility \u00b6 This workshop has been tested on the following platforms: OpenShift : version 4.4 Client: linux : version 4.15.0 OpenShift CLI : version 4.5.0 git : version 2.17.1 Apache Maven : version 3.6.0 Java version : version 11.0.6 Docker CE : version 19.03.6 curl : version 7.58.0 Credits \u00b6 Oliver Rodriguez Remko de Knikker","title":"About the workshop"},{"location":"#openshift-builds","text":"","title":"OpenShift Builds"},{"location":"#about-this-workshop","text":"A Build is the process to transform source code into a runnable image. A BuildConfig object is the definition of the entire build process. There are three primary Build strategies in OpenShift Container Platform (OCP) 4.x: Docker build, Source-to-Image (S2I) build, Custom build. The Pipeline build strategy using Jenkins is deprecated in OpenShift Container Platform (OCP) 4.x. The Jenkins pipeline is still available via the Jenkins operator. Equivalent and improved functionality is present in the OpenShift Pipelines based on Tekton .","title":"About this Workshop"},{"location":"#agenda","text":"Setup Pre-requirements for the workshop. Docker build Use Docker build strategy. Source-to-Image (S2I) Use Source-to-Image (S2I) build strategy. Pipeline build Use a Jenkins Pipeline and OpenShift Pipeline build strategy. Tekton Deployment Use Tekton to Deploy to OpenShift. See also Tekton Resources","title":"Agenda"},{"location":"#compatibility","text":"This workshop has been tested on the following platforms: OpenShift : version 4.4 Client: linux : version 4.15.0 OpenShift CLI : version 4.5.0 git : version 2.17.1 Apache Maven : version 3.6.0 Java version : version 11.0.6 Docker CE : version 19.03.6 curl : version 7.58.0","title":"Compatibility"},{"location":"#credits","text":"Oliver Rodriguez Remko de Knikker","title":"Credits"},{"location":"admin-guide/","text":"Admin Guide \u00b6 This section is comprised of the following steps: Instructor Step 1. Instructor Step \u00b6 Things specific to instructors can go here.","title":"Admin Guide"},{"location":"admin-guide/#admin-guide","text":"This section is comprised of the following steps: Instructor Step","title":"Admin Guide"},{"location":"admin-guide/#1-instructor-step","text":"Things specific to instructors can go here.","title":"1. Instructor Step"},{"location":"docker-build/","text":"Docker Build Strategy \u00b6 One of the build and deployment strategies on OpenShift is the Docker build strategy. A build is the process of transforming source code into a runnable image. The deployment uses the runnable image to deploy an application to a runtime environment. To define the build process OpenShift uses a BuildConfig . The Docker build strategy invokes the docker build command, and it expects a repository with a Dockerfile and all required artifacts in it to produce a runnable image. A DeploymentConfig is a way to create a ReplicationController and a strategy to start up pods on OpenShift. This lab guides you through the steps to implement the Docker build strategy on OpenShift to deploy an example application called spring-boot-app . Pre-requirements \u00b6 For this tutorial, you need access to among other aDocker and oc client with a Docker Engine. I strongly recommend to use the terminal that is part of the Theia Cloud IDE (with Docker) environment at https://labs.cognitiveclass.ai. To access the terminal that is part of Theia \u2014 Cloud IDE (With Docker) at Cognitive Class: Go to https://labs.cognitiveclass.ai , Sign up for CognitiveClass.ai using an IBM id or use your favorite social login, Login with your IBM Id or social login, Select Theia - Cloud IDE (With Docker), Select Terminal > New Terminal. Test you have access to the required clients, oc version git version mvn -v docker version curl --version Get Source Code \u00b6 Clone the spring-boot-app repository, git clone https://github.com/remkohdev/spring-boot-app.git cd spring-boot-app Test Maven Build \u00b6 Test maven build mvn clean install Test Docker Image \u00b6 Create the following Dockerfile, cat > Dockerfile <<EOF ARG JAR_FILE=target/*.jar # build stage FROM registry.access.redhat.com/ubi8/openjdk-11 COPY . . USER root RUN mvn clean install -DskipTests # runtime stage FROM registry.access.redhat.com/ubi8/openjdk-11 COPY --from=0 /home/jboss/target/*.jar /home/jboss/app.jar ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"] EOF Note : the mvn clean requires root access to delete the files in target. Starting a new stage, will reset the user to the default non-root user in the ubi image. Build and push the container image, docker build -t spring-boot-app . Run the container, docker run --name spring-boot-app -d -p 8080:8080 spring-boot-app curl -X GET \"http://localhost:8080/api/hello?name=Kumar\" Inspect, stop and remove image, docker ps -a docker logs spring-boot-app docker stop spring-boot-app docker rm spring-boot-app Push image to remote registry, docker tag spring-boot-app quay.io/remkohdev/spring-boot-app docker login quay.io -u remkohdev@gmail.com docker push quay.io/remkohdev/spring-boot-app Go to quay.io > repositories > spring-boot-app > Settings > Repository Visibility > make repository public Deploy to OpenShift from an Existing Image \u00b6 You can deploy applications directly from the OpenShift Web Console, Login to your OpenShift cluster, On IBM Cloud, list your Kubernetes clusters, select your cluster to go to your cluster Dashboard, and click the button Open Web Console > in the OpenShift Web Console, you can copy the login command under your profile icon, a new page will pop open with Display Token, click the link and copy the login command, e.g. oc login --token=abc --server=https://c321d.us-east.containers.cloud.ibm.com:31333 Create a new project, oc new-project oc-docker-build Go to the OpenShift Web Console, Switch to Developer mode, Go to Topology or click the +Add link, Select Container Image , and configure the Deploy Image , Image name from external registry : quay.io/ /spring-boot-app, Application Name : spring-boot-app, Name : spring-boot-app, Under Resources select Deployment , Check the Advanced Options for Create a route to the application , Click Create , Your application is running and is available via the Route. Clean up, oc delete project oc-docker-build Deploy to OpenShift \u00b6 Create a new project, oc new-project oc-docker-build Deploy the application from source with Docker build strategy using the Dockerfile, oc new-app . --strategy=docker Verify the resources were created successfully, oc get bc oc get builds oc get dc Create a Route, oc expose svc spring-boot-app ROUTE=$(oc get routes -o json | jq -r '.items[0].spec.host') Test deployment, curl \"http://$ROUTE/api/hello?name=Tao\" About Multi-stage Builds \u00b6 When you start containerizing an application, it is common to start with one Dockerfile for building images and running containers. It is common to have one Dockerfile for development, and a minimal image for production. This has been referred to as the builder pattern , but maintaining two Dockerfiles is not ideal. In multi-stage builds , you use multiple FROM statements in your Dockerfile. Each FROM statement begins a new stage of the build. You can selectively copy artifacts from one stage to another. Compare Dockerfile2 to Dockerfile .","title":"Docker build"},{"location":"docker-build/#docker-build-strategy","text":"One of the build and deployment strategies on OpenShift is the Docker build strategy. A build is the process of transforming source code into a runnable image. The deployment uses the runnable image to deploy an application to a runtime environment. To define the build process OpenShift uses a BuildConfig . The Docker build strategy invokes the docker build command, and it expects a repository with a Dockerfile and all required artifacts in it to produce a runnable image. A DeploymentConfig is a way to create a ReplicationController and a strategy to start up pods on OpenShift. This lab guides you through the steps to implement the Docker build strategy on OpenShift to deploy an example application called spring-boot-app .","title":"Docker Build Strategy"},{"location":"docker-build/#pre-requirements","text":"For this tutorial, you need access to among other aDocker and oc client with a Docker Engine. I strongly recommend to use the terminal that is part of the Theia Cloud IDE (with Docker) environment at https://labs.cognitiveclass.ai. To access the terminal that is part of Theia \u2014 Cloud IDE (With Docker) at Cognitive Class: Go to https://labs.cognitiveclass.ai , Sign up for CognitiveClass.ai using an IBM id or use your favorite social login, Login with your IBM Id or social login, Select Theia - Cloud IDE (With Docker), Select Terminal > New Terminal. Test you have access to the required clients, oc version git version mvn -v docker version curl --version","title":"Pre-requirements"},{"location":"docker-build/#get-source-code","text":"Clone the spring-boot-app repository, git clone https://github.com/remkohdev/spring-boot-app.git cd spring-boot-app","title":"Get Source Code"},{"location":"docker-build/#test-maven-build","text":"Test maven build mvn clean install","title":"Test Maven Build"},{"location":"docker-build/#test-docker-image","text":"Create the following Dockerfile, cat > Dockerfile <<EOF ARG JAR_FILE=target/*.jar # build stage FROM registry.access.redhat.com/ubi8/openjdk-11 COPY . . USER root RUN mvn clean install -DskipTests # runtime stage FROM registry.access.redhat.com/ubi8/openjdk-11 COPY --from=0 /home/jboss/target/*.jar /home/jboss/app.jar ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"] EOF Note : the mvn clean requires root access to delete the files in target. Starting a new stage, will reset the user to the default non-root user in the ubi image. Build and push the container image, docker build -t spring-boot-app . Run the container, docker run --name spring-boot-app -d -p 8080:8080 spring-boot-app curl -X GET \"http://localhost:8080/api/hello?name=Kumar\" Inspect, stop and remove image, docker ps -a docker logs spring-boot-app docker stop spring-boot-app docker rm spring-boot-app Push image to remote registry, docker tag spring-boot-app quay.io/remkohdev/spring-boot-app docker login quay.io -u remkohdev@gmail.com docker push quay.io/remkohdev/spring-boot-app Go to quay.io > repositories > spring-boot-app > Settings > Repository Visibility > make repository public","title":"Test Docker Image"},{"location":"docker-build/#deploy-to-openshift-from-an-existing-image","text":"You can deploy applications directly from the OpenShift Web Console, Login to your OpenShift cluster, On IBM Cloud, list your Kubernetes clusters, select your cluster to go to your cluster Dashboard, and click the button Open Web Console > in the OpenShift Web Console, you can copy the login command under your profile icon, a new page will pop open with Display Token, click the link and copy the login command, e.g. oc login --token=abc --server=https://c321d.us-east.containers.cloud.ibm.com:31333 Create a new project, oc new-project oc-docker-build Go to the OpenShift Web Console, Switch to Developer mode, Go to Topology or click the +Add link, Select Container Image , and configure the Deploy Image , Image name from external registry : quay.io/ /spring-boot-app, Application Name : spring-boot-app, Name : spring-boot-app, Under Resources select Deployment , Check the Advanced Options for Create a route to the application , Click Create , Your application is running and is available via the Route. Clean up, oc delete project oc-docker-build","title":"Deploy to OpenShift from an Existing Image"},{"location":"docker-build/#deploy-to-openshift","text":"Create a new project, oc new-project oc-docker-build Deploy the application from source with Docker build strategy using the Dockerfile, oc new-app . --strategy=docker Verify the resources were created successfully, oc get bc oc get builds oc get dc Create a Route, oc expose svc spring-boot-app ROUTE=$(oc get routes -o json | jq -r '.items[0].spec.host') Test deployment, curl \"http://$ROUTE/api/hello?name=Tao\"","title":"Deploy to OpenShift"},{"location":"docker-build/#about-multi-stage-builds","text":"When you start containerizing an application, it is common to start with one Dockerfile for building images and running containers. It is common to have one Dockerfile for development, and a minimal image for production. This has been referred to as the builder pattern , but maintaining two Dockerfiles is not ideal. In multi-stage builds , you use multiple FROM statements in your Dockerfile. Each FROM statement begins a new stage of the build. You can selectively copy artifacts from one stage to another. Compare Dockerfile2 to Dockerfile .","title":"About Multi-stage Builds"},{"location":"pipeline-build/images/","text":"Setup \u00b6 Kubernetes Cluster \u00b6 For an IBM led workshop, you can use a temporary free cluster that was pre-created for the purpose of the workshop. You need an IBM Cloud account to access your cluster, If you do not have IBM Cloud account yet, register at https://cloud.ibm.com/registration, Open the URL that was provided to you by the instructor to access your cluster, Log in to this IBM Cloud account using the workshop code and your IBM Cloud account IBM id, Instructions will ask to Log in to this IBM Cloud account Navigate to Clusters, And select the cluster assigned to you... Details for your cluster will load, Go to the Access menu item in the left navigation column, Follow the instructions to access your cluster from the client, If you need a cloudshell you can use https://shell.cloud.ibm.com/. It should be attached to your IBMid. It might take a few moments to create the instance and a new session, You should now be read to start with Lab 1 ,","title":"Setup"},{"location":"pipeline-build/images/#setup","text":"","title":"Setup"},{"location":"pipeline-build/images/#kubernetes-cluster","text":"For an IBM led workshop, you can use a temporary free cluster that was pre-created for the purpose of the workshop. You need an IBM Cloud account to access your cluster, If you do not have IBM Cloud account yet, register at https://cloud.ibm.com/registration, Open the URL that was provided to you by the instructor to access your cluster, Log in to this IBM Cloud account using the workshop code and your IBM Cloud account IBM id, Instructions will ask to Log in to this IBM Cloud account Navigate to Clusters, And select the cluster assigned to you... Details for your cluster will load, Go to the Access menu item in the left navigation column, Follow the instructions to access your cluster from the client, If you need a cloudshell you can use https://shell.cloud.ibm.com/. It should be attached to your IBMid. It might take a few moments to create the instance and a new session, You should now be read to start with Lab 1 ,","title":"Kubernetes Cluster"},{"location":"pipeline-build/images/README%20copy/","text":"Setup \u00b6 Kubernetes Cluster \u00b6 For an IBM led workshop, you can use a temporary free cluster that was pre-created for the purpose of the workshop. You need an IBM Cloud account to access your cluster, If you do not have IBM Cloud account yet, register at https://cloud.ibm.com/registration, Open the URL that was provided to you by the instructor to access your cluster, Log in to this IBM Cloud account using the workshop code and your IBM Cloud account IBM id, Instructions will ask to Log in to this IBM Cloud account Navigate to Clusters, And select the cluster assigned to you... Details for your cluster will load, Go to the Access menu item in the left navigation column, Follow the instructions to access your cluster from the client, If you need a cloudshell you can use https://shell.cloud.ibm.com/. It should be attached to your IBMid. It might take a few moments to create the instance and a new session, You should now be read to start with Lab 1 ,","title":"Setup"},{"location":"pipeline-build/images/README%20copy/#setup","text":"","title":"Setup"},{"location":"pipeline-build/images/README%20copy/#kubernetes-cluster","text":"For an IBM led workshop, you can use a temporary free cluster that was pre-created for the purpose of the workshop. You need an IBM Cloud account to access your cluster, If you do not have IBM Cloud account yet, register at https://cloud.ibm.com/registration, Open the URL that was provided to you by the instructor to access your cluster, Log in to this IBM Cloud account using the workshop code and your IBM Cloud account IBM id, Instructions will ask to Log in to this IBM Cloud account Navigate to Clusters, And select the cluster assigned to you... Details for your cluster will load, Go to the Access menu item in the left navigation column, Follow the instructions to access your cluster from the client, If you need a cloudshell you can use https://shell.cloud.ibm.com/. It should be attached to your IBMid. It might take a few moments to create the instance and a new session, You should now be read to start with Lab 1 ,","title":"Kubernetes Cluster"},{"location":"pipeline-build/lab-01/","text":"Create a Classic Pipeline with Jenkins on OpenShift 4.3 \u00b6 Requirements \u00b6 An IBM Cloud account An OpenShift 4.3 cluster with a minimum of 3 worker nodes Access to a terminal with the oc cli and ibmcloud cli, either using Skills Network or IBM Cloud shell . A Jenkins instance on OpenShift 4.3, see setup below, A Github fork of https://github.com/remkohdev/spring-client, Github personal access token Setup Jenkins on OpenShift 4.3 \u00b6 Go to Setup Jenkins on OpenShift 4.3 to complete the Jenkins setup and configuration on OpenShift 4.3 using the Jenkins Operator. Fork the spring-client App in Github \u00b6 To create a fork of the spring-client repository: Go to https://github.com/remkohdev/spring-client, Cick the Fork button in the to right to create a fork in your own GitHub organization, e.g. https://github.com/<username>/spring-client Review the Jenkinsfile that is included in the Spring Client repository, Edit the Jenkinsfile, Copy the login command to your OpenShift cluster, $ oc login https://c100-e.us-south.containers.cloud.ibm.com:30645 --token=CgwpwTu12sJV3u45iFFWd-6V7JsD8b90JBoJk1zGR2I In the environment section of the Jenkinsfile , change the LOGIN_URL and the LOGIN_PORT to match pipeline { agent { label 'maven' } environment { LOGIN_URL = 'https://c100-e.us-south.containers.cloud.ibm.com' LOGIN_PORT = '30645' } Commit changes to the Jenkinsfile to your Github fork. The Jenkins pipeline will use your Jenkinsfile to dpeloy your forked spring-client to your own OpenShift cluster. Create a Github Personal Access Token \u00b6 Login to your Github account at https://github.com/ Go to https://github.com/settings/tokens Click Generate new token Under Note add github-access-token-for-jenkins-on-openshift , Select the scopes for repo , read:repo_hook , and user , Click Generate token , Copy the token and save it, you need it to create the Jenkins pipeline from the Github source, E.g. create an environment variable GITHUB_TOKEN, export GITHUB_TOKEN=<your token> Configure Jenkins Access to OpenShift \u00b6 Go to the OpenShift web console again or use the Copy Login Command from earlier again, From the logged in user profile dropdown, click the Copy Login Command . The command should look like, oc login https://<your-openshift-url>:<your-openshift-port> --token=<your-openshift-api-token> Copy the OpenShift API token value, e.g. aaHYcMwUyyusfNaS45aAiQer_Kas1YUa45YTA2AxsNI, Go to the Jenkins dashboard, Click Credentials, or Go to Jenkins > Manage Jenkins > Configure Credentials Go to Credentials > System, In the System view, select the dropdown for Global credentials (unrestricted), From the drowdown, click Add credentials , The Jenkinsfile expects an OpenShift API token credential to be available named openshift-login-api-token , For Kind select Username with password , For Scope select Global , For Username enter token , For Password paste the OpenShift API token from the OpenShift web console login command, For ID enter openshift-login-api-token , which is the ID that the Jenkinsfile will look for, For Description enter openshift-login-api-token , Click OK, Create a Jenkins Pipeline \u00b6 Make sure a project springclient-ns exists in OpenShift, if no springclient-ns project exists, create it from the cloud shell, oc new-project springclient-ns Or via the UI, open the OpenShift web console, From the top navigation dropdown, go to the Cluster Console , Go to Administration > Projects, Filter projects by springclient-ns , If there is no such project, click Create Project to create it, The Jenkinsfile of the spring-client application defines a stage to delete and create the springclient-ns project. The delete step causes an error when the project it tries to delete is missing, Go back to the Jenkins dashboard. If you closed Jenkins, Go to the Application Console , and go to the project jenkins , Click the Route for External Traffic to open the Jenkins instance, Click Log in with OpenShift , In the Jenkins Dashboard, click Open Blue Ocean to open the Blue Ocean editor. If the Welcome to Jenkins popup window shows, click the Create a new Pipeline button, Otherwise, click the New Pipeline button in the Pipelines window. This will create a new Multibranch Pipeline, Select the GitHub option, In the Connect to GitHub section, paste the personal access token you created in your Github account, Click Connect, Select the organization to where you forked the spring-client repository, Search for and select the spring-client repo, Click Create Pipeline, When the pipeline creation is completed, a build is triggered automatically, You should see a successful build of the pipeline, If an error occurs, you can debug the pipeline by unfolding the red cross indicating on the stage, which indicates the pipeline failed in that stage, Unfold the step in the stage, to see the log output, Any update to the Github repository, e.g. a push to update the Jenkinsfile, source code of the Spring Boot application, or the README.md file, will automatically trigger a new build of the pipeline, If you're interested, review the pipeline settings: Click the Configure option, Review the settings, From the cloud shell, make sure you're logged in to the OpenShift console, Use the project oc project springclient-ns , oc project springclient-ns outputs, $ oc project springclient-ns Now using project \"springclient-ns\" on server \"https://c100-e.us-south.containers.cloud.ibm.com:30645\". Get the route and test the deployment, ROUTE=\"$(oc get route springclient -o json | jq -r '.spec .host')\" curl -X GET http://$ROUTE/api/hello?name=you outputs, ROUTE=\"$(oc get route springclient -o json | jq -r '.spec .host')\" curl -X GET http://$ROUTE/api/hello?name=you { \"message\" : \"Hello you\" }","title":"1. Classic Pipeline with Jenkins"},{"location":"pipeline-build/lab-01/#create-a-classic-pipeline-with-jenkins-on-openshift-43","text":"","title":"Create a Classic Pipeline with Jenkins on OpenShift 4.3"},{"location":"pipeline-build/lab-01/#requirements","text":"An IBM Cloud account An OpenShift 4.3 cluster with a minimum of 3 worker nodes Access to a terminal with the oc cli and ibmcloud cli, either using Skills Network or IBM Cloud shell . A Jenkins instance on OpenShift 4.3, see setup below, A Github fork of https://github.com/remkohdev/spring-client, Github personal access token","title":"Requirements"},{"location":"pipeline-build/lab-01/#setup-jenkins-on-openshift-43","text":"Go to Setup Jenkins on OpenShift 4.3 to complete the Jenkins setup and configuration on OpenShift 4.3 using the Jenkins Operator.","title":"Setup Jenkins on OpenShift 4.3"},{"location":"pipeline-build/lab-01/#fork-the-spring-client-app-in-github","text":"To create a fork of the spring-client repository: Go to https://github.com/remkohdev/spring-client, Cick the Fork button in the to right to create a fork in your own GitHub organization, e.g. https://github.com/<username>/spring-client Review the Jenkinsfile that is included in the Spring Client repository, Edit the Jenkinsfile, Copy the login command to your OpenShift cluster, $ oc login https://c100-e.us-south.containers.cloud.ibm.com:30645 --token=CgwpwTu12sJV3u45iFFWd-6V7JsD8b90JBoJk1zGR2I In the environment section of the Jenkinsfile , change the LOGIN_URL and the LOGIN_PORT to match pipeline { agent { label 'maven' } environment { LOGIN_URL = 'https://c100-e.us-south.containers.cloud.ibm.com' LOGIN_PORT = '30645' } Commit changes to the Jenkinsfile to your Github fork. The Jenkins pipeline will use your Jenkinsfile to dpeloy your forked spring-client to your own OpenShift cluster.","title":"Fork the spring-client App in Github"},{"location":"pipeline-build/lab-01/#create-a-github-personal-access-token","text":"Login to your Github account at https://github.com/ Go to https://github.com/settings/tokens Click Generate new token Under Note add github-access-token-for-jenkins-on-openshift , Select the scopes for repo , read:repo_hook , and user , Click Generate token , Copy the token and save it, you need it to create the Jenkins pipeline from the Github source, E.g. create an environment variable GITHUB_TOKEN, export GITHUB_TOKEN=<your token>","title":"Create a Github Personal Access Token"},{"location":"pipeline-build/lab-01/#configure-jenkins-access-to-openshift","text":"Go to the OpenShift web console again or use the Copy Login Command from earlier again, From the logged in user profile dropdown, click the Copy Login Command . The command should look like, oc login https://<your-openshift-url>:<your-openshift-port> --token=<your-openshift-api-token> Copy the OpenShift API token value, e.g. aaHYcMwUyyusfNaS45aAiQer_Kas1YUa45YTA2AxsNI, Go to the Jenkins dashboard, Click Credentials, or Go to Jenkins > Manage Jenkins > Configure Credentials Go to Credentials > System, In the System view, select the dropdown for Global credentials (unrestricted), From the drowdown, click Add credentials , The Jenkinsfile expects an OpenShift API token credential to be available named openshift-login-api-token , For Kind select Username with password , For Scope select Global , For Username enter token , For Password paste the OpenShift API token from the OpenShift web console login command, For ID enter openshift-login-api-token , which is the ID that the Jenkinsfile will look for, For Description enter openshift-login-api-token , Click OK,","title":"Configure Jenkins Access to OpenShift"},{"location":"pipeline-build/lab-01/#create-a-jenkins-pipeline","text":"Make sure a project springclient-ns exists in OpenShift, if no springclient-ns project exists, create it from the cloud shell, oc new-project springclient-ns Or via the UI, open the OpenShift web console, From the top navigation dropdown, go to the Cluster Console , Go to Administration > Projects, Filter projects by springclient-ns , If there is no such project, click Create Project to create it, The Jenkinsfile of the spring-client application defines a stage to delete and create the springclient-ns project. The delete step causes an error when the project it tries to delete is missing, Go back to the Jenkins dashboard. If you closed Jenkins, Go to the Application Console , and go to the project jenkins , Click the Route for External Traffic to open the Jenkins instance, Click Log in with OpenShift , In the Jenkins Dashboard, click Open Blue Ocean to open the Blue Ocean editor. If the Welcome to Jenkins popup window shows, click the Create a new Pipeline button, Otherwise, click the New Pipeline button in the Pipelines window. This will create a new Multibranch Pipeline, Select the GitHub option, In the Connect to GitHub section, paste the personal access token you created in your Github account, Click Connect, Select the organization to where you forked the spring-client repository, Search for and select the spring-client repo, Click Create Pipeline, When the pipeline creation is completed, a build is triggered automatically, You should see a successful build of the pipeline, If an error occurs, you can debug the pipeline by unfolding the red cross indicating on the stage, which indicates the pipeline failed in that stage, Unfold the step in the stage, to see the log output, Any update to the Github repository, e.g. a push to update the Jenkinsfile, source code of the Spring Boot application, or the README.md file, will automatically trigger a new build of the pipeline, If you're interested, review the pipeline settings: Click the Configure option, Review the settings, From the cloud shell, make sure you're logged in to the OpenShift console, Use the project oc project springclient-ns , oc project springclient-ns outputs, $ oc project springclient-ns Now using project \"springclient-ns\" on server \"https://c100-e.us-south.containers.cloud.ibm.com:30645\". Get the route and test the deployment, ROUTE=\"$(oc get route springclient -o json | jq -r '.spec .host')\" curl -X GET http://$ROUTE/api/hello?name=you outputs, ROUTE=\"$(oc get route springclient -o json | jq -r '.spec .host')\" curl -X GET http://$ROUTE/api/hello?name=you { \"message\" : \"Hello you\" }","title":"Create a Jenkins Pipeline"},{"location":"pipeline-build/lab-01/SETUP/","text":"Setup Jenkins on OpenShift 3 \u00b6 From the IBM Cloud cluster dashboard, open the OpenShift web console, Go to the Service Catalog , First we need to create a project named jenkins to deploy the Jenkins service to, Click the + Create Project button, For Name enter jenkins , For Desription enter Project for Jenkins, Click Create, Or from the cloud shell, $ oc new-project jenkins Now using project \"jenkins\" on server \"https://c107-e.us-south.containers.cloud.ibm.com:31608\". Go back to the Service Catalog, Search the catalog for Jenkins (Ephemeral) or go to the CD/CD tab, Click the Jenkins (Ephemeral) service, note that the ephemeral version does not include persistent storage, so your data will be lost if the pod goes down, but for this tutorial it is easier to setup, For Add to Project select jenkins , Click Create, If a popup Confirm Creation appears, click Create Anyway , Click Close while Jenkins is being provisioned in jenkins , Select the Application Console , and go to your project jenkins , Go to Overview, and wait until Jenkins has been provisioned, the pod should color bright blue, If provisioning fails the first time because of a timeout during pulling of images, simply deploy the service again, To see the log for a deployment #1, go to Applications > Deployments > Jenkins > #1, Click the Logs tab, Or go to Monitoring to see a detailed status, Open Jenkins in a new tab by clicking the Jenkins route URL in the Overview , e.g. https://jenkins-ci1.cda-openshift-cluster-1c0e8bfb1c68214cf875a9ca7dd1e060-0001.us-south.containers.appdomain.cloud, Click Log in with OpenShift, Click Allow selected permissions , Jenkins web will open, Configure Jenkins Go to Jenkins > Manage Jenkins > Global Tool Configuration, Go to the Maven section, Click Maven Installations , If no Maven installer is configured, click Add Maven , Configure the Name to be maven , check the option Install automatically and select version 3.6.3 , Click Save, Go back to Lab01 to continue the Jenkins setup.","title":"Setup Jenkins on OpenShift 3"},{"location":"pipeline-build/lab-01/SETUP/#setup-jenkins-on-openshift-3","text":"From the IBM Cloud cluster dashboard, open the OpenShift web console, Go to the Service Catalog , First we need to create a project named jenkins to deploy the Jenkins service to, Click the + Create Project button, For Name enter jenkins , For Desription enter Project for Jenkins, Click Create, Or from the cloud shell, $ oc new-project jenkins Now using project \"jenkins\" on server \"https://c107-e.us-south.containers.cloud.ibm.com:31608\". Go back to the Service Catalog, Search the catalog for Jenkins (Ephemeral) or go to the CD/CD tab, Click the Jenkins (Ephemeral) service, note that the ephemeral version does not include persistent storage, so your data will be lost if the pod goes down, but for this tutorial it is easier to setup, For Add to Project select jenkins , Click Create, If a popup Confirm Creation appears, click Create Anyway , Click Close while Jenkins is being provisioned in jenkins , Select the Application Console , and go to your project jenkins , Go to Overview, and wait until Jenkins has been provisioned, the pod should color bright blue, If provisioning fails the first time because of a timeout during pulling of images, simply deploy the service again, To see the log for a deployment #1, go to Applications > Deployments > Jenkins > #1, Click the Logs tab, Or go to Monitoring to see a detailed status, Open Jenkins in a new tab by clicking the Jenkins route URL in the Overview , e.g. https://jenkins-ci1.cda-openshift-cluster-1c0e8bfb1c68214cf875a9ca7dd1e060-0001.us-south.containers.appdomain.cloud, Click Log in with OpenShift, Click Allow selected permissions , Jenkins web will open, Configure Jenkins Go to Jenkins > Manage Jenkins > Global Tool Configuration, Go to the Maven section, Click Maven Installations , If no Maven installer is configured, click Add Maven , Configure the Name to be maven , check the option Install automatically and select version 3.6.3 , Click Save, Go back to Lab01 to continue the Jenkins setup.","title":"Setup Jenkins on OpenShift 3"},{"location":"pipeline-build/lab-02/","text":"Using a Pipeline Build Strategy on OpenShift 4.3 \u00b6 With the release of OpenShift Pipelines based on Tekton, the pipelines build strategy has been deprecated. Users should either use Jenkins files directly on Jenkins or use cloud-native CI/CD with Openshift Pipelines. OpenShift Pipelines give you control over building, deploying, and promoting your applications on OpenShift. Using a combination of the Jenkins Pipeline Build Strategy, Jenkinsfiles, and the OpenShift Domain Specific Language (DSL) (provided by the OpenShift Jenkins Client Plug-in), you can create advanced build, test, deploy, and promote pipelines for any scenario. The OpenShift Jenkins Client Plug-in must be installed on your Jenkins master. The OpenShift Jenkins Client Plug-in provides a fluent-styled DSL for communicating with the OpenShift API from within the Jenkins slaves. The OpenShift DSL is based on Groovy syntax and provides methods for controlling the lifecycle of your application such as create, build, deploy, and delete. This strategy defaults to using a jenkinsfile. The jenkinsfile is executed on the Jenkins slave pod. This lab creates an OpenShift Pipeline to build the springclient application instead of a pure Jenkins Pipeline. The OpenShift Pipeline still uses the Jenkins Pipeline strategy but OpenShift will now create a Jenkins slave to execute the pipeline and managing the Pipeline is now done in OpenShift. Clean up Existing Deployment \u00b6 Go to the Cloud Shell and make sure you are logged in to your cluster, Delete the existing project, oc delete project jenkins oc delete project springclient-ns outputs, $ oc delete project jenkins project.project.openshift.io \"jenkins\" deleted $ oc delete project springclient-ns project.project.openshift.io \"springclient-ns\" deleted Your existing Jenkins deployment should be deleted, as well as your springclient deployment. Deploy the Spring Client \u00b6 From the cloud shell, Create the project anew, oc new-project springclient-ns Create the BuildConfig declaration file using a Jenkins pipeline strategy, use your own forked repo instead of the one listed in the spec.source.git.uri attribute here, and set the spec.strategy.jenkinsPipelineStrategy.env environment vairables to match your cluster's LOGIN_URL and LOGIN_PORT found via the Copy Login Command , echo 'kind: \"BuildConfig\" apiVersion: \"v1\"metadata: name: \"spring-client-pipeline\" namespace: springclient-ns spec: source: git: uri: \"https://github.com/remkohdev/spring-client\" ref: \"master\" strategy: jenkinsPipelineStrategy: jenkinsfilePath: Jenkinsfile-oc env: - name: \"LOGIN_URL\" value: \"https://c103-e.us-south.containers.cloud.ibm.com\" - name: \"LOGIN_PORT\" value: \"32110\" - name: \"PROJECT\" value: \"springclient-ns\"' > spring-client-pipeline.yaml A BuildConfig or build configuration describes a build definition and triggers for when a new build should be created. The Pipeline build strategy allows you to define a Jenkins pipeline for execution by the Jenkins pipeline plugin . The first time a user defines a build configuration in a project using a Pipeline strategy, OpenShift Container Platform instantiates a Jenkins server to execute the pipeline. To be sure, close any tabs open to the Jenkins instance. Review the Jenkinsfile called Jenkinsfile-oc for the OpenShift Pipeline at https://github.com/remkohdev/spring-client/Jenkinsfile-oc. The pipeline is using the Maven DSL (Domain Specific Language) and the OpenShift DSL. Create a Jenkins master, oc new-app jenkins-ephemeral outputs, $ oc new-app jenkins-ephemeral --> Deploying template \"openshift/jenkins-ephemeral\" to project springclient-ns Jenkins (Ephemeral) --------- Jenkins service, without persistent storage. WARNING: Any data stored will be lost upon pod destruction. Only use this template for testing. A Jenkins service has been created in your project. Log into Jenkins with your OpenShift account. The tutorial at https://github.com/openshift/origin/blob/master/examples/jenkins/README.md contains more information about using this template. * With parameters: * Jenkins Service Name=jenkins * Jenkins JNLP Service Name=jenkins-jnlp * Enable OAuth in Jenkins=true * Memory Limit=1Gi * Jenkins ImageStream Namespace=openshift * Disable memory intensive administrative monitors=false * Jenkins ImageStreamTag=jenkins:2 * Allows use of Jenkins Update Center repository with invalid SSL certificate=false --> Creating resources ... route.route.openshift.io \"jenkins\" created deploymentconfig.apps.openshift.io \"jenkins\" created serviceaccount \"jenkins\" created rolebinding.authorization.openshift.io \"jenkins_edit\" created service \"jenkins-jnlp\" created service \"jenkins\" created --> Success Access your application via route 'jenkins-springclient-ns.remkohdev-roks43-785329-2bef1f4b4097001da9502000c44fc2b2-0000.sjc03.containers.appdomain.cloud' Run 'oc status' to view your app. Create the BuildConfig and the OpenShift Pipeline, oc create -f spring-client-pipeline.yaml outputs, $ oc create -f spring-client-pipeline.yaml buildconfig.build.openshift.io/spring-client-pipeline created Go to Builds > Build Configs , Start a build of the pipeline, $ oc start-build spring-client-pipeline build.build.openshift.io/spring-client-pipeline-1 started Go to Builds > Builds . Open the springclient-ns project. Once the Jenkins instance is created, the Jenkins instance will start the pipeline to create the springclient application. A pipeline build was started, The View logs will open the Jenkins instance, Resources \u00b6 See: https://docs.openshift.com/container-platform/4.3/builds/build-strategies.html#builds-strategy-pipeline-build_build-strategies","title":"2. OpenShift Pipeline with Jenkins"},{"location":"pipeline-build/lab-02/#using-a-pipeline-build-strategy-on-openshift-43","text":"With the release of OpenShift Pipelines based on Tekton, the pipelines build strategy has been deprecated. Users should either use Jenkins files directly on Jenkins or use cloud-native CI/CD with Openshift Pipelines. OpenShift Pipelines give you control over building, deploying, and promoting your applications on OpenShift. Using a combination of the Jenkins Pipeline Build Strategy, Jenkinsfiles, and the OpenShift Domain Specific Language (DSL) (provided by the OpenShift Jenkins Client Plug-in), you can create advanced build, test, deploy, and promote pipelines for any scenario. The OpenShift Jenkins Client Plug-in must be installed on your Jenkins master. The OpenShift Jenkins Client Plug-in provides a fluent-styled DSL for communicating with the OpenShift API from within the Jenkins slaves. The OpenShift DSL is based on Groovy syntax and provides methods for controlling the lifecycle of your application such as create, build, deploy, and delete. This strategy defaults to using a jenkinsfile. The jenkinsfile is executed on the Jenkins slave pod. This lab creates an OpenShift Pipeline to build the springclient application instead of a pure Jenkins Pipeline. The OpenShift Pipeline still uses the Jenkins Pipeline strategy but OpenShift will now create a Jenkins slave to execute the pipeline and managing the Pipeline is now done in OpenShift.","title":"Using a Pipeline Build Strategy on OpenShift 4.3"},{"location":"pipeline-build/lab-02/#clean-up-existing-deployment","text":"Go to the Cloud Shell and make sure you are logged in to your cluster, Delete the existing project, oc delete project jenkins oc delete project springclient-ns outputs, $ oc delete project jenkins project.project.openshift.io \"jenkins\" deleted $ oc delete project springclient-ns project.project.openshift.io \"springclient-ns\" deleted Your existing Jenkins deployment should be deleted, as well as your springclient deployment.","title":"Clean up Existing Deployment"},{"location":"pipeline-build/lab-02/#deploy-the-spring-client","text":"From the cloud shell, Create the project anew, oc new-project springclient-ns Create the BuildConfig declaration file using a Jenkins pipeline strategy, use your own forked repo instead of the one listed in the spec.source.git.uri attribute here, and set the spec.strategy.jenkinsPipelineStrategy.env environment vairables to match your cluster's LOGIN_URL and LOGIN_PORT found via the Copy Login Command , echo 'kind: \"BuildConfig\" apiVersion: \"v1\"metadata: name: \"spring-client-pipeline\" namespace: springclient-ns spec: source: git: uri: \"https://github.com/remkohdev/spring-client\" ref: \"master\" strategy: jenkinsPipelineStrategy: jenkinsfilePath: Jenkinsfile-oc env: - name: \"LOGIN_URL\" value: \"https://c103-e.us-south.containers.cloud.ibm.com\" - name: \"LOGIN_PORT\" value: \"32110\" - name: \"PROJECT\" value: \"springclient-ns\"' > spring-client-pipeline.yaml A BuildConfig or build configuration describes a build definition and triggers for when a new build should be created. The Pipeline build strategy allows you to define a Jenkins pipeline for execution by the Jenkins pipeline plugin . The first time a user defines a build configuration in a project using a Pipeline strategy, OpenShift Container Platform instantiates a Jenkins server to execute the pipeline. To be sure, close any tabs open to the Jenkins instance. Review the Jenkinsfile called Jenkinsfile-oc for the OpenShift Pipeline at https://github.com/remkohdev/spring-client/Jenkinsfile-oc. The pipeline is using the Maven DSL (Domain Specific Language) and the OpenShift DSL. Create a Jenkins master, oc new-app jenkins-ephemeral outputs, $ oc new-app jenkins-ephemeral --> Deploying template \"openshift/jenkins-ephemeral\" to project springclient-ns Jenkins (Ephemeral) --------- Jenkins service, without persistent storage. WARNING: Any data stored will be lost upon pod destruction. Only use this template for testing. A Jenkins service has been created in your project. Log into Jenkins with your OpenShift account. The tutorial at https://github.com/openshift/origin/blob/master/examples/jenkins/README.md contains more information about using this template. * With parameters: * Jenkins Service Name=jenkins * Jenkins JNLP Service Name=jenkins-jnlp * Enable OAuth in Jenkins=true * Memory Limit=1Gi * Jenkins ImageStream Namespace=openshift * Disable memory intensive administrative monitors=false * Jenkins ImageStreamTag=jenkins:2 * Allows use of Jenkins Update Center repository with invalid SSL certificate=false --> Creating resources ... route.route.openshift.io \"jenkins\" created deploymentconfig.apps.openshift.io \"jenkins\" created serviceaccount \"jenkins\" created rolebinding.authorization.openshift.io \"jenkins_edit\" created service \"jenkins-jnlp\" created service \"jenkins\" created --> Success Access your application via route 'jenkins-springclient-ns.remkohdev-roks43-785329-2bef1f4b4097001da9502000c44fc2b2-0000.sjc03.containers.appdomain.cloud' Run 'oc status' to view your app. Create the BuildConfig and the OpenShift Pipeline, oc create -f spring-client-pipeline.yaml outputs, $ oc create -f spring-client-pipeline.yaml buildconfig.build.openshift.io/spring-client-pipeline created Go to Builds > Build Configs , Start a build of the pipeline, $ oc start-build spring-client-pipeline build.build.openshift.io/spring-client-pipeline-1 started Go to Builds > Builds . Open the springclient-ns project. Once the Jenkins instance is created, the Jenkins instance will start the pipeline to create the springclient application. A pipeline build was started, The View logs will open the Jenkins instance,","title":"Deploy the Spring Client"},{"location":"pipeline-build/lab-02/#resources","text":"See: https://docs.openshift.com/container-platform/4.3/builds/build-strategies.html#builds-strategy-pipeline-build_build-strategies","title":"Resources"},{"location":"setup/","text":"Pre-work \u00b6 This section is broken up into the following steps: Sign up for IBM Cloud Download or clone the repo 1. Sign up for IBM Cloud \u00b6 Ensure you have an IBM Cloud ID 2. Download or clone the repo \u00b6 Various parts of this workshop will require the attendee to upload files or run scripts that we've stored in the repository. So let's get that done early on, you'll need git on your laptop to clone the repository directly, or access to GitHub.com to download the zip file. To Download, go to the GitHub repo for this workshop and download the archived version of the workshop and extract it on your laptop. Alternately, run the following command: git clone https://github.com/IBM/workshop-template cd workshop-template","title":"Setup"},{"location":"setup/#pre-work","text":"This section is broken up into the following steps: Sign up for IBM Cloud Download or clone the repo","title":"Pre-work"},{"location":"setup/#1-sign-up-for-ibm-cloud","text":"Ensure you have an IBM Cloud ID","title":"1. Sign up for IBM Cloud"},{"location":"setup/#2-download-or-clone-the-repo","text":"Various parts of this workshop will require the attendee to upload files or run scripts that we've stored in the repository. So let's get that done early on, you'll need git on your laptop to clone the repository directly, or access to GitHub.com to download the zip file. To Download, go to the GitHub repo for this workshop and download the archived version of the workshop and extract it on your laptop. Alternately, run the following command: git clone https://github.com/IBM/workshop-template cd workshop-template","title":"2. Download or clone the repo"},{"location":"tekton-build/","text":"Tekton Pipelines for OpenShift \u00b6 Resources \u00b6 Tekton Tutorial for OpenShift IBM Cloud Garage Tekton Pipelines Using Tekton Pipelines for Example Health App Tekton Pipeline Tutorial Video Cloud-Native CD Pipelines with Tekton Deploy an App using Tekton Creating CI/CD Pipelines with Tekton","title":"Tekton Pipelines for OpenShift"},{"location":"tekton-build/#tekton-pipelines-for-openshift","text":"","title":"Tekton Pipelines for OpenShift"},{"location":"tekton-build/#resources","text":"Tekton Tutorial for OpenShift IBM Cloud Garage Tekton Pipelines Using Tekton Pipelines for Example Health App Tekton Pipeline Tutorial Video Cloud-Native CD Pipelines with Tekton Deploy an App using Tekton Creating CI/CD Pipelines with Tekton","title":"Resources"},{"location":"using-templates/","text":"Using Templates \u00b6 A Template is an OpenShift object that describes a set of objects that can be parameterized and processed. Using the CLI, you can process a file defining a template to return the list of objects to standard output. Using a Template \u00b6 Create a new Template file template.yaml , cat > template.yaml <<EOF apiVersion: v1 kind: Template metadata: name: spring-boot-app namespace: ${NAMESPACE_NAME} annotations: description: \"Spring Boot App\" tags: spring-boot, java parameters: - name: NAMESPACE_NAME description: Name of the namespace required: true value: oc-docker-build - name: APPLICATION_NAME description: Name of the application image required: true value: spring-boot-app - name: APPLICATION_IMAGE description: Full location of the application image required: true value: quay.io/remkohdev/spring-boot-app - name: APPLICATION_PORT description: Port to access the application image required: true value: \"8080\" labels: app: ${APPLICATION_NAME} objects: - apiVersion: apps.openshift.io/v1 kind: DeploymentConfig metadata: name: ${APPLICATION_NAME} namespace: ${NAMESPACE_NAME} labels: app: ${APPLICATION_NAME} spec: replicas: 3 selector: app: ${APPLICATION_NAME} strategy: type: Rolling template: metadata: labels: app: ${APPLICATION_NAME} spec: containers: - image: ${APPLICATION_IMAGE} name: ${APPLICATION_NAME} imagePullPolicy: Always ports: - containerPort: ${APPLICATION_PORT} protocol: TCP - apiVersion: v1 kind: Service metadata: labels: app: ${APPLICATION_NAME} name: ${APPLICATION_NAME} namespace: ${NAMESPACE_NAME} spec: ports: - name: tcp-port protocol: TCP port: ${APPLICATION_PORT} targetPort: ${APPLICATION_PORT} selector: app: ${APPLICATION_NAME} deploymentconfig: ${APPLICATION_NAME} type: ClusterIP - apiVersion: route.openshift.io/v1 kind: Route metadata: labels: app: ${APPLICATION_NAME} name: ${APPLICATION_NAME} namespace: ${NAMESPACE_NAME} spec: port: targetPort: tcp-port to: kind: Service name: ${APPLICATION_NAME} weight: 100 wildcardPolicy: None EOF Process the template and pipe the list of objects to create in the active OpenShift project, oc process -f template.yaml | oc create -f - The following objects were created, % oc get all NAME READY STATUS RESTARTS AGE pod/spring-boot-app-1-7qvxd 1/1 Running 0 17m pod/spring-boot-app-1-8rxkp 1/1 Running 0 17m pod/spring-boot-app-1-deploy 0/1 Completed 0 17m pod/spring-boot-app-1-pgsk7 1/1 Running 0 17m NAME DESIRED CURRENT READY AGE replicationcontroller/spring-boot-app-1 3 3 3 17m NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/spring-boot-app ClusterIP 172.21.191.199 <none> 8080/TCP 17m NAME REVISION DESIRED CURRENT TRIGGERED BY deploymentconfig.apps.openshift.io/spring-boot-app 1 3 3 config NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD route.route.openshift.io/spring-boot-app spring-boot-app-oc-docker-build.remkohdev-roks44-3n-clu-2bef1f4b4097001da9502000c44fc2b2-0000.us-south.containers.appdomain.cloud spring-boot-app 8080-tcp None Because I am creating the application from an existing image, no BuildConfig was defined. Create an Application from Template \u00b6 Create and store the application template, oc create -f template.yaml List the stored templates oc get templates NAME DESCRIPTION PARAMETERS OBJECTS spring-boot-app Spring Boot App 4 (all set) 3 Create the application from the stored template, oc new-app spring-boot-app --build-env strategy.dockerStrategy.dockerfilePath=./Dockerfile1","title":"Using Templates"},{"location":"using-templates/#using-templates","text":"A Template is an OpenShift object that describes a set of objects that can be parameterized and processed. Using the CLI, you can process a file defining a template to return the list of objects to standard output.","title":"Using Templates"},{"location":"using-templates/#using-a-template","text":"Create a new Template file template.yaml , cat > template.yaml <<EOF apiVersion: v1 kind: Template metadata: name: spring-boot-app namespace: ${NAMESPACE_NAME} annotations: description: \"Spring Boot App\" tags: spring-boot, java parameters: - name: NAMESPACE_NAME description: Name of the namespace required: true value: oc-docker-build - name: APPLICATION_NAME description: Name of the application image required: true value: spring-boot-app - name: APPLICATION_IMAGE description: Full location of the application image required: true value: quay.io/remkohdev/spring-boot-app - name: APPLICATION_PORT description: Port to access the application image required: true value: \"8080\" labels: app: ${APPLICATION_NAME} objects: - apiVersion: apps.openshift.io/v1 kind: DeploymentConfig metadata: name: ${APPLICATION_NAME} namespace: ${NAMESPACE_NAME} labels: app: ${APPLICATION_NAME} spec: replicas: 3 selector: app: ${APPLICATION_NAME} strategy: type: Rolling template: metadata: labels: app: ${APPLICATION_NAME} spec: containers: - image: ${APPLICATION_IMAGE} name: ${APPLICATION_NAME} imagePullPolicy: Always ports: - containerPort: ${APPLICATION_PORT} protocol: TCP - apiVersion: v1 kind: Service metadata: labels: app: ${APPLICATION_NAME} name: ${APPLICATION_NAME} namespace: ${NAMESPACE_NAME} spec: ports: - name: tcp-port protocol: TCP port: ${APPLICATION_PORT} targetPort: ${APPLICATION_PORT} selector: app: ${APPLICATION_NAME} deploymentconfig: ${APPLICATION_NAME} type: ClusterIP - apiVersion: route.openshift.io/v1 kind: Route metadata: labels: app: ${APPLICATION_NAME} name: ${APPLICATION_NAME} namespace: ${NAMESPACE_NAME} spec: port: targetPort: tcp-port to: kind: Service name: ${APPLICATION_NAME} weight: 100 wildcardPolicy: None EOF Process the template and pipe the list of objects to create in the active OpenShift project, oc process -f template.yaml | oc create -f - The following objects were created, % oc get all NAME READY STATUS RESTARTS AGE pod/spring-boot-app-1-7qvxd 1/1 Running 0 17m pod/spring-boot-app-1-8rxkp 1/1 Running 0 17m pod/spring-boot-app-1-deploy 0/1 Completed 0 17m pod/spring-boot-app-1-pgsk7 1/1 Running 0 17m NAME DESIRED CURRENT READY AGE replicationcontroller/spring-boot-app-1 3 3 3 17m NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/spring-boot-app ClusterIP 172.21.191.199 <none> 8080/TCP 17m NAME REVISION DESIRED CURRENT TRIGGERED BY deploymentconfig.apps.openshift.io/spring-boot-app 1 3 3 config NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD route.route.openshift.io/spring-boot-app spring-boot-app-oc-docker-build.remkohdev-roks44-3n-clu-2bef1f4b4097001da9502000c44fc2b2-0000.us-south.containers.appdomain.cloud spring-boot-app 8080-tcp None Because I am creating the application from an existing image, no BuildConfig was defined.","title":"Using a Template"},{"location":"using-templates/#create-an-application-from-template","text":"Create and store the application template, oc create -f template.yaml List the stored templates oc get templates NAME DESCRIPTION PARAMETERS OBJECTS spring-boot-app Spring Boot App 4 (all set) 3 Create the application from the stored template, oc new-app spring-boot-app --build-env strategy.dockerStrategy.dockerfilePath=./Dockerfile1","title":"Create an Application from Template"}]}